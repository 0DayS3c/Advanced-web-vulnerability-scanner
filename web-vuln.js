(function() {
    const vulnerabilities = [];

    // Helper function to check if a URL is an external redirect
    function isExternalRedirect(url) {
        try {
            const parsedUrl = new URL(url);
            return parsedUrl.hostname !== window.location.hostname;
        } catch (e) {
            return false;
        }
    }

    // Basic Scan: Check for open redirects
    function basicCheckOpenRedirects() {
        const links = document.querySelectorAll('a[href]');
        links.forEach(link => {
            const href = link.href;
            const urlParams = new URL(href).searchParams;
            urlParams.forEach((value, key) => {
                if (/redirect|returnurl/i.test(key)) {
                    if (isExternalRedirect(value)) {
                        vulnerabilities.push(`Basic: Potential open redirect parameter found: ${href}`);
                    }
                }
            });
        });
    }

    // Advanced Scan: Check for open redirects in forms and other elements
    function advancedCheckOpenRedirects() {
        const links = document.querySelectorAll('a[href]');
        links.forEach(link => {
            const href = link.href;
            if (isExternalRedirect(href)) {
                vulnerabilities.push(`Advanced: Potential open redirect found in link: ${href}`);
            }
        });

        const forms = document.querySelectorAll('form');
        forms.forEach(form => {
            const action = form.action;
            if (action && isExternalRedirect(action)) {
                vulnerabilities.push(`Advanced: Potential open redirect in form action: ${action}`);
            }
        });

        // Check other elements with href attributes
        document.querySelectorAll('[href]').forEach(el => {
            const href = el.getAttribute('href');
            if (href && isExternalRedirect(href)) {
                vulnerabilities.push(`Advanced: Potential open redirect in element with href: ${href}`);
            }
        });
    }

    // Basic Scan: Check for CSRF protection in forms
    function basicCheckCSRFProtection() {
        const forms = document.querySelectorAll('form');
        forms.forEach(form => {
            if (!form.querySelector('[name="csrf-token"]') &&
                !form.querySelector('meta[name="csrf-token"]')) {
                vulnerabilities.push('Basic: Potential CSRF vulnerability found in form: ' + (form.action || 'unknown action'));
            }
        });
    }

    // Advanced Scan: Enhanced CSRF protection checks
    function advancedCheckCSRFProtection() {
        const forms = document.querySelectorAll('form');
        forms.forEach(form => {
            const inputs = form.querySelectorAll('input');
            let hasToken = false;
            inputs.forEach(input => {
                if (/csrf/i.test(input.name) || /csrf/i.test(input.id)) {
                    hasToken = true;
                }
            });

            const metaTags = document.querySelectorAll('meta[name="csrf-token"], meta[name="csrf"]');
            if (!hasToken && metaTags.length === 0) {
                vulnerabilities.push('Advanced: Potential CSRF vulnerability found in form: ' + (form.action || 'unknown action'));
            }
        });

        // Check for JavaScript-based CSRF token setup
        const scriptTags = document.querySelectorAll('script');
        scriptTags.forEach(script => {
            if (script.textContent.includes('csrf-token')) {
                vulnerabilities.push('Advanced: CSRF token found in inline script');
            }
        });
    }

    // Basic Scan: Check for insecure cookies (conceptual)
    function basicCheckInsecureCookies() {
        vulnerabilities.push('Basic: Insecure cookie check cannot be fully supported in client-side JavaScript. Use server-side tools.');
    }

    // Advanced Scan: More comprehensive checks for cookie security (conceptual)
    function advancedCheckInsecureCookies() {
        vulnerabilities.push('Advanced: Comprehensive cookie security check cannot be fully supported in client-side JavaScript. Consider using server-side tools.');
    }

    // Basic Scan: Check for exposed sensitive information
    function basicCheckSensitiveInfo() {
        const sensitiveKeywords = ['password', 'secret', 'token'];
        const scripts = Array.from(document.querySelectorAll('script[src], script')).filter(script => script.src || script.innerHTML);

        scripts.forEach(script => {
            const url = script.src;
            if (url) {
                fetch(url)
                    .then(response => response.text())
                    .then(text => {
                        sensitiveKeywords.forEach(keyword => {
                            if (text.toLowerCase().includes(keyword.toLowerCase())) {
                                vulnerabilities.push(`Basic: Potential sensitive information leak found in script: ${url}`);
                            }
                        });
                    })
                    .catch(err => console.warn(`Basic: Could not fetch ${url}: ${err}`));
            } else {
                const text = script.innerHTML;
                sensitiveKeywords.forEach(keyword => {
                    if (text.toLowerCase().includes(keyword.toLowerCase())) {
                        vulnerabilities.push('Basic: Potential sensitive information found in inline script.');
                    }
                });
            }
        });
    }

    // Advanced Scan: Enhanced sensitive information detection
    async function advancedCheckSensitiveInfo() {
        const sensitivePatterns = [
            /password/i, /secret/i, /token/i, /api_key/i, /key/i, /credential/i,
            /authorization/i, /bearer/i, /auth/i, /private/i
        ];

        const scripts = Array.from(document.querySelectorAll('script[src], script')).filter(script => script.src || script.innerHTML);
        const checks = scripts.map(script => {
            const url = script.src;
            if (url) {
                return fetch(url)
                    .then(response => response.text())
                    .then(text => {
                        sensitivePatterns.forEach(pattern => {
                            if (pattern.test(text)) {
                                vulnerabilities.push(`Advanced: Potential sensitive information leak found in script: ${url}`);
                            }
                        });
                    })
                    .catch(err => console.warn(`Advanced: Could not fetch ${url}: ${err}`));
            } else {
                const text = script.innerHTML;
                sensitivePatterns.forEach(pattern => {
                    if (pattern.test(text)) {
                        vulnerabilities.push('Advanced: Potential sensitive information found in inline script.');
                    }
                });
            }
        });

        // Check meta tags and data attributes
        document.querySelectorAll('meta, [data-]').forEach(el => {
            const html = el.outerHTML;
            sensitivePatterns.forEach(pattern => {
                if (pattern.test(html)) {
                    vulnerabilities.push(`Advanced: Potential sensitive information found in element: ${html}`);
                }
            });
        });

        await Promise.all(checks);
    }

    // Function to log results
    function logResults() {
        if (vulnerabilities.length > 0) {
            console.log('Potential vulnerabilities found:');
            vulnerabilities.forEach(vuln => console.log(vuln));
        } else {
            console.log('No vulnerabilities found.');
        }
    }

    // Run all checks
    async function runChecks() {
        basicCheckOpenRedirects();
        basicCheckCSRFProtection();
        basicCheckInsecureCookies();
        basicCheckSensitiveInfo();

        await Promise.all([
            advancedCheckOpenRedirects(),
            advancedCheckCSRFProtection(),
            advancedCheckInsecureCookies(),
            advancedCheckSensitiveInfo()
        ]);

        logResults();
    }

    // Start the scan
    runChecks();
})();
